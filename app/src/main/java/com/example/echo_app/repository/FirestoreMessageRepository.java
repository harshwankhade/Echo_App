package com.example.echo_app.repository;

import android.util.Log;

import com.example.echo_app.model.Message;
import com.google.android.gms.tasks.Task;
import com.google.android.gms.tasks.Tasks;
import com.google.firebase.firestore.DocumentSnapshot;
import com.google.firebase.firestore.FirebaseFirestore;
import com.google.firebase.firestore.Query;
import com.google.firebase.firestore.QuerySnapshot;

import java.util.ArrayList;
import java.util.List;

/**
 * FirestoreMessageRepository.java
 *
 * Implementation of MessageRepository using Firebase Firestore as the backend.
 *
 * Provides CRUD operations for Message documents stored in Firestore subcollections.
 * Messages are organized in: chats/{chatId}/messages/{messageId}
 * All operations are asynchronous and return Task<T> for non-blocking execution.
 *
 * Features:
 * - Firebase Firestore as data source
 * - Subcollection queries for message organization
 * - Message ordering by timestamp
 * - Asynchronous operations using Task API
 * - Automatic serialization/deserialization of Message POJOs
 * - Comprehensive error handling and logging
 * - Collection reference constants for maintainability
 *
 * Usage:
 * MessageRepository messageRepository = new FirestoreMessageRepository();
 * messageRepository.getMessagesByChatId("chatId123")
 *     .addOnSuccessListener(messages -> { /* handle messages * })
 *     .addOnFailureListener(e -> { /* handle error *});
 */
public class FirestoreMessageRepository implements MessageRepository {

    private static final String TAG = "FirestoreMessageRepository";
    private static final String CHATS_COLLECTION = "chats";
    private static final String MESSAGES_SUBCOLLECTION = "messages";

    private final FirebaseFirestore db;

    /**
     * Default constructor.
     * Initializes Firebase Firestore instance for database operations.
     */
    public FirestoreMessageRepository() {
        this.db = FirebaseFirestore.getInstance();
    }

    /**
     * Retrieve all messages for a specific chat.
     *
     * Fetches all message documents from a chat's subcollection.
     * Messages are ordered by timestamp in ascending order (oldest first).
     * For large message volumes, consider implementing pagination.
     *
     * @param chatId The unique identifier of the chat
     * @return Task<List<Message>> - Task that completes with a list of Message objects
     *         ordered by timestamp, or fails with an exception on error
     *
     * Firestore Path: chats/{chatId}/messages/
     * Query: All documents ordered by timestamp ascending
     * Order: Oldest messages first
     */
    @Override
    public Task<List<Message>> getMessagesByChatId(String chatId) {
        if (chatId == null || chatId.isEmpty()) {
            Log.e(TAG, "Cannot get messages: chatId is null or empty");
            return Tasks.forException(new IllegalArgumentException("chatId must not be null or empty"));
        }

        Log.d(TAG, "Fetching messages for chat: " + chatId);

        return db.collection(CHATS_COLLECTION)
                .document(chatId)
                .collection(MESSAGES_SUBCOLLECTION)
                .orderBy("timestamp", Query.Direction.ASCENDING)
                .get()
                .continueWith(task -> {
                    if (!task.isSuccessful()) {
                        Exception exception = task.getException();
                        Log.e(TAG, "Error fetching messages for chat: " + chatId, exception);
                        throw exception != null ? exception : new Exception("Unknown error");
                    }

                    QuerySnapshot querySnapshot = task.getResult();
                    if (querySnapshot == null) {
                        Log.e(TAG, "QuerySnapshot is null for chat: " + chatId);
                        throw new Exception("QuerySnapshot is null");
                    }

                    List<Message> messageList = new ArrayList<>();

                    for (DocumentSnapshot document : querySnapshot.getDocuments()) {
                        Message message = document.toObject(Message.class);
                        if (message != null) {
                            messageList.add(message);
                        }
                    }

                    Log.d(TAG, "Fetched " + messageList.size() + " messages for chat: " + chatId);
                    return messageList;
                });
    }

    /**
     * Send a new message to a chat.
     *
     * Creates a new message document in the chat's messages subcollection.
     * The message ID is auto-generated by Firestore.
     * The deliveryStatus should be set to "sent" in the Message object before calling.
     *
     * @param message The Message object to send
     * @return Task<Void> - Task that completes when the message is successfully added,
     *         or fails with an exception on error
     *
     * Firestore Path: chats/{message.chatId}/messages/
     * Operation: Add (create new document with auto-generated ID)
     * Prerequisites: message.chatId must reference an existing chat
     */
    @Override
    public Task<Void> sendMessage(Message message) {
        if (message == null || message.getChatId() == null) {
            Log.e(TAG, "Cannot send message: message or chatId is null");
            return Tasks.forException(new IllegalArgumentException("Message and chatId must not be null"));
        }

        Log.d(TAG, "Sending message to chat: " + message.getChatId());

        return db.collection(CHATS_COLLECTION)
                .document(message.getChatId())
                .collection(MESSAGES_SUBCOLLECTION)
                .add(message)
                .continueWith(task -> {
                    if (!task.isSuccessful()) {
                        Exception exception = task.getException();
                        Log.e(TAG, "Error sending message to chat: " + message.getChatId(), exception);
                        throw exception != null ? exception : new Exception("Unknown error");
                    }

                    com.google.firebase.firestore.DocumentReference result = task.getResult();
                    if (result != null) {
                        String messageId = result.getId();
                        Log.d(TAG, "Message sent successfully with ID: " + messageId);
                    }
                    return null;
                });
    }

    /**
     * Update a message's delivery status.
     *
     * Modifies the deliveryStatus field of an existing message.
     * Status progression: "sent" → "delivered" → "seen"
     * The messageId parameter must include the full path context (chatId and messageId).
     *
     * @param messageId The unique identifier of the message (in format: "chatId/messageId")
     * @param newStatus The new delivery status ("sent", "delivered", or "seen")
     * @return Task<Void> - Task that completes when the status is successfully updated,
     *         or fails with an exception on error
     *
     * Firestore Path: chats/{chatId}/messages/{messageId}
     * Operation: Update field (deliveryStatus)
     * Status Values: "sent", "delivered", "seen"
     */
    @Override
    public Task<Void> updateMessageStatus(String messageId, String newStatus) {
        if (messageId == null || messageId.isEmpty()) {
            Log.e(TAG, "Cannot update message status: messageId is null or empty");
            return Tasks.forException(new IllegalArgumentException("messageId must not be null or empty"));
        }

        if (newStatus == null || newStatus.isEmpty()) {
            Log.e(TAG, "Cannot update message status: newStatus is null or empty");
            return Tasks.forException(new IllegalArgumentException("newStatus must not be null or empty"));
        }

        Log.d(TAG, "Updating message status: " + messageId + " to " + newStatus);

        // Extract chatId and actual messageId from the parameter
        String[] parts = messageId.split("/");
        if (parts.length != 2) {
            Log.e(TAG, "Invalid messageId format. Expected: 'chatId/messageId', got: " + messageId);
            return Tasks.forException(new IllegalArgumentException("messageId must be in format: 'chatId/messageId'"));
        }

        String chatId = parts[0];
        String actualMessageId = parts[1];

        return db.collection(CHATS_COLLECTION)
                .document(chatId)
                .collection(MESSAGES_SUBCOLLECTION)
                .document(actualMessageId)
                .update("deliveryStatus", newStatus)
                .addOnSuccessListener(aVoid -> {
                    Log.d(TAG, "Message status updated successfully: " + messageId);
                })
                .addOnFailureListener(e -> {
                    Log.e(TAG, "Error updating message status: " + messageId, e);
                });
    }

    /**
     * Delete a message from a chat.
     *
     * Removes a message document from the chat's messages subcollection.
     * Typically only the sender can delete their own messages.
     * The messageId parameter must include the full path context (chatId and messageId).
     *
     * @param messageId The unique identifier of the message (in format: "chatId/messageId")
     * @return Task<Void> - Task that completes when the message is successfully deleted,
     *         or fails with an exception on error
     *
     * Firestore Path: chats/{chatId}/messages/{messageId}
     * Operation: Delete document
     * Permissions: Sender or admin only (enforced by Security Rules)
     */
    @Override
    public Task<Void> deleteMessage(String messageId) {
        if (messageId == null || messageId.isEmpty()) {
            Log.e(TAG, "Cannot delete message: messageId is null or empty");
            return Tasks.forException(new IllegalArgumentException("messageId must not be null or empty"));
        }

        Log.d(TAG, "Deleting message: " + messageId);

        // Extract chatId and actual messageId from the parameter
        String[] parts = messageId.split("/");
        if (parts.length != 2) {
            Log.e(TAG, "Invalid messageId format. Expected: 'chatId/messageId', got: " + messageId);
            return Tasks.forException(new IllegalArgumentException("messageId must be in format: 'chatId/messageId'"));
        }

        String chatId = parts[0];
        String actualMessageId = parts[1];

        return db.collection(CHATS_COLLECTION)
                .document(chatId)
                .collection(MESSAGES_SUBCOLLECTION)
                .document(actualMessageId)
                .delete()
                .addOnSuccessListener(aVoid -> {
                    Log.d(TAG, "Message deleted successfully: " + messageId);
                })
                .addOnFailureListener(e -> {
                    Log.e(TAG, "Error deleting message: " + messageId, e);
                });
    }
}

